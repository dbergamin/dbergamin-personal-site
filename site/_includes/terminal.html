<div id="terminal-container">
  <div id="terminal-header">
     <span id="terminal-title">dansh - guest@danielbergamin.net</span>
  </div>
  <div id="terminal-body" class="background-nodes">
    <div id="terminal-command-template" style="display: none">
      <span class="terminal-prompt"></span>
      <span class="terminal-command"></span>
    </div>
    <div id="terminal-output-template" style="display: none">
      <span class="terminal-output"></span>
    </div>
    <div class="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~ $ </span>
      <span class="terminal-command">cd public/</span>
    </div>
    <div class="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~/public $ </span>
      <span class="terminal-command">ls</span>
    </div>
    <div class="terminal-line">
      <span class="terminal-output">
        <span><a href="{% link blog.markdown %}">[ blog/ ]</a></span>
        <span><a href="{% link about.markdown %}">[ about.html ]</a></span>
        <span><a href="{% link cv.markdown %}">[ cv.html ]</a></span>
      </span>
    </div>
    <div class="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~/public $ </span>
      <input id="active-terminal-command" class="terminal-command" autofocus/><span id="terminal-cursor">â–ˆ</span>
    </div>
  </div>
</div>

<!-- 
  Makes our toy terminal tick.
  This has gradually got a bit spaghetti and needs a refactor.
-->
<script type="text/javascript">
  // Constants
  const KEYPRESS_RETURN = 13;
  const KEYPRESS_UP = 38; 
  const NO_ARGS = "";
  const NO_COMMAND_HISTORY_CYCLED = -2
  const NOT_VIEWABLE = "plain_file_object_"; 

  // Globals holding the 'terminal' state
  // It would be great if JS supported more appropriate data types, but I'd rather slog through
  // with objects and arrays than add a dependency for a very limited problem.
  var TERMINAL_BODY = document.querySelector('#terminal-body');
  var TERMINAL_ACTIVE_COMMAND_LINE = TERMINAL_BODY.lastElementChild;
  var TERMINAL_ACTIVE_COMMAND = document.querySelector('#active-terminal-command'); 
  var TERMINAL_ACTIVE_DIR = ["~","public"];
  var TERMINAL_COMMAND_HISTORY = [];
  var TERMINAL_COMMAND_HISTORY_POSITION = NO_COMMAND_HISTORY_CYCLED;
  var TERMINAL_FILESYSTEM = {
    "~": {
      ".": NOT_VIEWABLE,
      "public": {
        ".": "/",
        "blog": {
          ".": "/blog/"
        },
        "about.html": "/about.html",
        "cv.html": "/cv.html"
      }
    }
  };


  class TerminalCommand {
    constructor(name, regex, exec, helptext) {
      this.name = name;
      this.regex = regex;
      this.exec = exec;
      this.helptext = helptext;
    }
  }

  class TerminalFsObject {
    constructor(name, data, isDir) {
      this.name = name;
      this.isDir = isDir;
      this.isFile = !isDir;

      if (this.isFile) {
        this.weblink = data;
      } else if (isDir) {
        this.weblink = data['.'];
      }
    }

    // Renders HTML for output onto the terminal
    renderToHtml() {
      var fileOutput = document.createElement('span');
      fileOutput.innerHTML = `<a href='${this.weblink}'>[ ${this.name} ]</a> `;
      return fileOutput;
    }
  }

  var TERMINAL_COMMANDS = [
    new TerminalCommand('cd', '^cd(.*)?', commandChangeDir, "Changes the current directory"),
    new TerminalCommand('clear', '^(clear|cls)(.*)?', commandClearScreen, "Clears the terminal contents"),
    new TerminalCommand('help', '^help(.*)?', commandHelp, "Print help information"),
    new TerminalCommand('ls', '^ls(.*)?', commandListDir, "Show clickable links to contents of current directory"),
    new TerminalCommand('print', '^print(.*)?', commandPrint, "Print some text to the terminal output")
  ];

  class TerminalInterface {

    constructor() {
      this.wireTerminalUIEvents();
    }

    wireTerminalUIEvents() {
      // Make the entire line focus the input as it will start at zero length
      TERMINAL_BODY.addEventListener("click",function() {
        TERMINAL_ACTIVE_COMMAND.focus();
      });
      
      // Resizing the input so caret stays at the end
      TERMINAL_ACTIVE_COMMAND.addEventListener('input',function() {
        // Throw an error if too much text gets dumped in
        if (this.getBoundingClientRect().width >= this.parentElement.getBoundingClientRect().width) {
          leaveMeAlone();
          this.value = "";
        }
        this.style.width = this.value.length + "ch";
      });
      
      // Trigger input event to activate the resizing
      TERMINAL_ACTIVE_COMMAND.dispatchEvent(new Event('input'));
      
      // Hook up the eval method
      TERMINAL_ACTIVE_COMMAND.addEventListener('keyup', this.evaluateInput);
    }

    triggerResize() {
      TERMINAL_ACTIVE_COMMAND.dispatchEvent(new Event('input'));
    }

    evaluateInput(event) {
      var matchedCommand = false;

      if (event.keyCode === KEYPRESS_RETURN) {
        var input = this.value.toLowerCase();
        TERMINAL_COMMAND_HISTORY_POSITION = NO_COMMAND_HISTORY_CYCLED;

        Object.keys(TERMINAL_COMMANDS).forEach(function(command_id) {
          if (input.match(TERMINAL_COMMANDS[command_id].regex)) {
            // Record the user input
            recordCommand();

            // If input matches a command definition, invoke the command with the raw input string
            var userCommandArgs;
            var spacePosition = input.indexOf(" ");
            if (spacePosition >= 0) {
              userCommandArgs = input.substring(spacePosition + 1);
            } else {
              userCommandArgs = NO_ARGS;
            }
            TERMINAL_COMMANDS[command_id].exec(userCommandArgs);
            matchedCommand = true;
          }
        });

        if (!matchedCommand) {
          commandNotFound(input);
        }
        
        // Reset the active command prompt and scroll it to the bottom
        TERMINAL_ACTIVE_COMMAND_LINE.getElementsByClassName('terminal-command')[0].value = '';
        TERMINAL_ACTIVE_COMMAND_LINE.getElementsByClassName('terminal-prompt')[0].innerText = getTerminalPrompt();
        TERMINAL_ACTIVE_COMMAND.dispatchEvent(new Event('input'));
        TERMINAL_BODY.scrollTop = TERMINAL_BODY.scrollHeight;
    
      } else if (event.keyCode === KEYPRESS_UP) {
        // Implement 'command history cycling'; pressing 'UP' retrieves past commands
        if (TERMINAL_COMMAND_HISTORY.length >= 1) {
          if (TERMINAL_COMMAND_HISTORY_POSITION == NO_COMMAND_HISTORY_CYCLED) {
            TERMINAL_COMMAND_HISTORY_POSITION = TERMINAL_COMMAND_HISTORY.length - 1;
          } else if (TERMINAL_COMMAND_HISTORY_POSITION == -1) {
            // We have exhausted our pool of historical commands, do nothing
            return;
          }
          TERMINAL_ACTIVE_COMMAND_LINE.getElementsByClassName('terminal-command')[0].value = TERMINAL_COMMAND_HISTORY[TERMINAL_COMMAND_HISTORY_POSITION];
          TERMINAL_COMMAND_HISTORY_POSITION--;
          TERMINAL_ACTIVE_COMMAND.dispatchEvent(new Event('input'));
        }
      }
    }
  }

  var TERMINAL_INTERFACE = new TerminalInterface();

  /*************************
   ** Terminal behaviours **
   *************************/

  /*
   * Records the current command and prepare the terminal for the next command
   * 1. Create a new terminal line object with values based on the command entered
   * 2. Drop it into place in the 'shell' on the penultimate line
   * 3. Clean up the active command line so the user can type a new command
   */
  function recordCommand() {
    // Grab the final line of the terminal; containing the active command and store the command text
    var commandText = TERMINAL_ACTIVE_COMMAND_LINE.getElementsByClassName('terminal-command')[0].value;
    var promptText = TERMINAL_ACTIVE_COMMAND_LINE.getElementsByClassName('terminal-prompt')[0].innerText;

    // Create the line to be returned with appropriate values
    var newLine = document.querySelector('#terminal-command-template').cloneNode(true);
    with (newLine) {
      getElementsByClassName('terminal-command')[0].innerText = commandText;
      getElementsByClassName('terminal-prompt')[0].innerText = promptText;
      id = '';
      className = 'terminal-line';
      removeAttribute('style');
    }

    TERMINAL_COMMAND_HISTORY.push(commandText);

    // Insert it into the DOM
    TERMINAL_BODY.insertBefore(newLine,TERMINAL_ACTIVE_COMMAND_LINE);
  }

  // Prints files to terminal output
  function printFiles(files) {

    // Create the line to be returned from the template
    var newLine = document.querySelector('#terminal-output-template').cloneNode(true);
    with (newLine) {
      id = '';
      className = 'terminal-line';
      removeAttribute('style');
    }

    // Populate the new line with the file output
    var filesHtmlOutput = [];
    for (const rawFsObject in files) {
      // Check if the raw object is an object or a string to check if it is a file or directory
      var fsObject = new TerminalFsObject(rawFsObject, files[rawFsObject], files[rawFsObject] instanceof Object);
      filesHtmlOutput.push(fsObject.renderToHtml());
    }

    for (const fileOutput in filesHtmlOutput) {
      newLine.appendChild(filesHtmlOutput[fileOutput]);
    }

    // Finally, add the new line to the DOM
    TERMINAL_BODY.insertBefore(newLine,TERMINAL_ACTIVE_COMMAND_LINE);
  }

  function printText(text) {
    // Create the line to be returned from the template
    var newLine = document.querySelector('#terminal-output-template').cloneNode(true);

    with (newLine) {
      getElementsByClassName('terminal-output')[0].innerText = text;
      id = '';
      className = 'terminal-line';
      removeAttribute('style');
    }

    // Insert it
    TERMINAL_BODY.insertBefore(newLine,TERMINAL_ACTIVE_COMMAND_LINE);
  }

  function getTerminalPrompt() {
    return `guest@danielbergamin.net:${TERMINAL_ACTIVE_DIR.join('/')} $`;
  }

  function getPathFromString(path) {
    if (path == '/') {
      return ['~'];
    } else {
      return path.split('/');
    }
  }

  // Check if a path exists
  function isValidFilePath(path) {
    var splitPath = getPathFromString(path)
    var i = 0;
    var seekDir = TERMINAL_FILESYSTEM;
    while (i < splitPath.length && seekDir != undefined) {
      seekDir = seekDir[splitPath[i]];
      i = i + 1;
    }
    
    return (seekDir != undefined)
  }

  function isAbsoluteFilePath(path) {
    return path.startsWith("~") || path.startsWith("/");
  }

  /*******************************************************************************
   * Command implementations
   * Parameters:
   *   args: The raw string that follows the space after the command invocation
   *         e.g. the command "print hello 123" would pass "hello 123" in as args.
   *******************************************************************************/

  // A lot of the hacky logic in here should be moved into a mini class handling terminal FS state
  // But perfect being the enemy of done, here we are...
  function commandChangeDir(args) {
    var pathToChangeTo = args;
    if (pathToChangeTo.split(' ').length != 1 || pathToChangeTo === NO_ARGS) {
      printText('Usage: cd [DIRECTORY_PATH]');
    } else {
      if (pathToChangeTo == "..") {
        if (TERMINAL_ACTIVE_DIR.length > 1) {
          TERMINAL_ACTIVE_DIR.pop();
        }
      } else {
        // Transform relative paths into absolute
        if (!isAbsoluteFilePath(pathToChangeTo)) {
          pathToChangeTo = TERMINAL_ACTIVE_DIR.join('/').concat("/",pathToChangeTo);
        }
        if (isValidFilePath(pathToChangeTo)) {
          TERMINAL_ACTIVE_DIR = getPathFromString(pathToChangeTo);
        } else {
          printText(`cd: directory ${pathToChangeTo} not found`)
        }
      }
    }
  }

  function commandClearScreen(args) {
    var lines = document.getElementsByClassName('terminal-line');
    // Iterate in reverse, skipping the bottom line as this contains the command
    for (var i = lines.length - 2; i >= 0; i--) {
      lines[i].remove();
    }
  }

  function commandHelp(args) {
    var output = "This isn't a great way to navigate the site, but it was fun to make. Supported commands:\n";
    for (command in TERMINAL_COMMANDS) {
      output = output + `${TERMINAL_COMMANDS[command].name}: ${TERMINAL_COMMANDS[command].helptext}\n`;
    }
    printText(output);
  }

  function commandListDir(args) {
    var i = 0;
    var seekDir = TERMINAL_FILESYSTEM;
    while (i < TERMINAL_ACTIVE_DIR.length) {
      seekDir = seekDir[TERMINAL_ACTIVE_DIR[i]];
      i = i + 1;
    }

    printFiles(seekDir);
  }

  // Display an error if the command is not found.
  function commandNotFound(args) {
    alert("command " + args + " not found. Use `help` for more info.");
  }


  function commandPrint(args) {
    printText(args);
  }

  // Generic error behaviour
  function leaveMeAlone() {
    alert("Please don't try to break my fragile imitation of a shell, no bug bounties to be found here.");
  }

</script>