<div id="terminal-container">
  <div id="terminal-header">
     <span id="terminal-title">dansh - guest@danielbergamin.net</span>
  </div>
  <div id="terminal-body" class="background-nodes">
    <div id="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~ $ </span>
      <span class="terminal-command">cd public/</span>
    </div>
    <div id="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~/public $ </span>
      <span class="terminal-command">ls</span>
    </div>
    <div id="terminal-line">
      <span class="terminal-output">
        <span><a href="{% link blog.markdown %}">[ blog/ ]</a></span>
        <span><a href="{% link about.markdown %}">[ about.html ]</a></span>
        <span><a href="{% link cv.markdown %}">[ cv.html ]</a></span>
      </span>
    </div>
    <div id="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~/public $ </span>
      <input id="active-terminal-command" class="terminal-command" autofocus/><span id="terminal-cursor">â–ˆ</span>
    </div>
  </div>
</div>

<!-- Make our vanity shell interface tick -->
<script type="text/javascript">
  // Make the input resize dynamically so the fake blinking caret can stick at the end
  var consoleInput = document.querySelector('#active-terminal-command');
  consoleInput.addEventListener('input', resizeInput);
  resizeInput.call(consoleInput);

  function resizeInput() {
    // Throw an error if too much text gets dumped in
    if (this.getBoundingClientRect().width >= this.parentElement.getBoundingClientRect().width) {
      leaveMeAlone();
      this.value = "";
    }
    this.style.width = this.value.length + "ch";
  }

  // Make the entire line focus the input as it will start at zero length
  document.querySelector('#terminal-body').addEventListener("click",function() {
    document.querySelector('#active-terminal-command').focus();
  });

  /* Logic to handle basic commands */
  // Constants
  const RETURN = 13;
  
  // List of commands
  supportedCommands = {
    'print(.*)?': commandPrint
  }

  // REPL logic
  consoleInput.addEventListener('keyup', evaluate);
  function evaluate(event) {
    matchedCommand = false;

    if (event.keyCode === RETURN) {
      input = this.value.toLowerCase();
      Object.keys(supportedCommands).forEach(function(command) {
        if (input.match(command)) {
          // If input matches a command definition, invoke the command with the raw input string
          supportedCommands[command](input);
          matchedCommand = true;
        }
      });

      if (!matchedCommand) {
        commandNotFound(input);
      }
    }
  }

  // Adding new lines
  function print(text) {
    
  }

  // Command implementations
  function commandPrint(input) {
    var terminalBody = document.querySelector('#terminal-body');
    
  }

  function commandNotFound(input) {
    alert("command " + input + " not found");
  }

  // Generic error behaviour
  function leaveMeAlone() {
    alert("Please don't try to break my fragile imitation of a shell, no bug bounties to be found here.");
  }

</script>