<div id="terminal-container">
  <div id="terminal-header">
     <span id="terminal-title">dansh - guest@danielbergamin.net</span>
  </div>
  <div id="terminal-body" class="background-nodes">
    <div id="terminal-command-template" style="display: none">
      <span class="terminal-prompt"></span>
      <span class="terminal-command"></span>
    </div>
    <div id="terminal-output-template" style="display: none">
      <span class="terminal-output"></span>
    </div>
    <div class="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~ $ </span>
      <span class="terminal-command">cd public/</span>
    </div>
    <div class="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~/public $ </span>
      <span class="terminal-command">ls</span>
    </div>
    <div class="terminal-line">
      <span class="terminal-output">
        <span><a href="{% link blog.markdown %}">[ blog/ ]</a></span>
        <span><a href="{% link about.markdown %}">[ about.html ]</a></span>
        <span><a href="{% link cv.markdown %}">[ cv.html ]</a></span>
      </span>
    </div>
    <div class="terminal-line">
      <span class="terminal-prompt">guest@danielbergamin.net:~/public $ </span>
      <input id="active-terminal-command" class="terminal-command" autofocus/><span id="terminal-cursor">â–ˆ</span>
    </div>
  </div>
</div>

<!-- Make our vanity shell interface tick -->
<script type="text/javascript">
  // Make the input resize dynamically so the fake blinking caret can stick at the end
  var TERMINAL_BODY = document.querySelector('#terminal-body');
  var TERMINAL_INPUT = document.querySelector('#active-terminal-command');
  TERMINAL_INPUT.addEventListener('input', resizeInput);
  resizeInput.call(TERMINAL_INPUT);

  function resizeInput() {
    // Throw an error if too much text gets dumped in
    if (this.getBoundingClientRect().width >= this.parentElement.getBoundingClientRect().width) {
      leaveMeAlone();
      this.value = "";
    }
    this.style.width = this.value.length + "ch";
  }

  // Make the entire line focus the input as it will start at zero length
  document.querySelector('#terminal-body').addEventListener("click",function() {
    document.querySelector('#active-terminal-command').focus();
  });

  /* Logic to handle basic commands */
  // Constants
  const KEYPRESS_RETURN = 13;
  const KEYPRESS_UP = 38; 
  const NO_ARGS = "";
  const NO_COMMAND_HISTORY_CYCLED = -2
  const NOT_VIEWABLE = "plain_file_object_"; 

  // Globals holding the 'terminal' state
  // It would be great if JS supported more appropriate data types, but I'd rather slog through
  // with objects and arrays than add a dependency for a very limited pactiveCommandLine.getElementsByClassName('terminal-command')[0].value("abc123")roblem.
  var TERMINAL_ACTIVE_DIR = ["~","public"];
  var TERMINAL_COMMAND_HISTORY = [];
  var TERMINAL_COMMAND_HISTORY_POSITION = NO_COMMAND_HISTORY_CYCLED;
  var TERMINAL_FILESYSTEM = {
    "~": {
      ".": NOT_VIEWABLE,
      "public": {
        ".": "/",
        "blog": {
          ".": "/blog/"
        },
        "about.html": "/about.html",
        "cv.html": "/cv.html"
      }
    }
  };

  class TerminalCommand {
    constructor(name, regex, exec, helptext) {
      this.name = name;
      this.regex = regex;
      this.exec = exec;
      this.helptext = helptext;
    }
  }

  class TerminalFsObject {
    constructor(name, data, isDir) {
      this.name = name;
      this.isDir = isDir;
      this.isFile = !isDir;

      if (this.isFile) {
        this.weblink = data;
      } else if (isDir) {
        this.weblink = data['.'];
      }
    }

    // Renders HTML for output onto the terminal
    renderToHtml() {
      var fileOutput = document.createElement('span');
      fileOutput.innerHTML = `<a href='${this.weblink}'>[ ${this.name} ]</a> `;
      return fileOutput;
    }
  }

  var TERMINAL_COMMANDS = [
    new TerminalCommand('cd', '^cd(.*)?', commandChangeDir, "Changes the current directory"),
    new TerminalCommand('clear', '^(clear|cls)(.*)?', commandClearScreen, "Clears the terminal contents"),
    new TerminalCommand('help', '^help(.*)?', commandHelp, "Print help information"),
    new TerminalCommand('ls', '^ls(.*)?', commandListDir, "Show clickable links to contents of current directory"),
    new TerminalCommand('print', '^print(.*)?', commandPrint, "Print some text to the terminal output")
  ];

  // REPL 'logic'
  TERMINAL_INPUT.addEventListener('keyup', evaluate);
  
  function evaluate(event) {
    matchedCommand = false;

    if (event.keyCode === KEYPRESS_RETURN) {
      input = this.value.toLowerCase();
      TERMINAL_COMMAND_HISTORY_POSITION = NO_COMMAND_HISTORY_CYCLED;

      Object.keys(TERMINAL_COMMANDS).forEach(function(command_id) {
        if (input.match(TERMINAL_COMMANDS[command_id].regex)) {
          // Record the user input
          recordCommand();

          // If input matches a command definition, invoke the command with the raw input string
          var userCommandArgs;
          spacePosition = input.indexOf(" ");
          if (spacePosition >= 0) {
            userCommandArgs = input.substring(spacePosition + 1);
          } else {
            userCommandArgs = NO_ARGS;
          }
          TERMINAL_COMMANDS[command_id].exec(userCommandArgs);
          matchedCommand = true;
        }
      });

      if (!matchedCommand) {
        commandNotFound(input);
      }
      
      // Reset the active command prompt and scroll it to the bottom
      TERMINAL_BODY.lastElementChild.getElementsByClassName('terminal-command')[0].value = '';
      TERMINAL_BODY.lastElementChild.getElementsByClassName('terminal-prompt')[0].innerText = getTerminalPath();
      resizeInput.call(TERMINAL_INPUT);
      TERMINAL_BODY.scrollTop = TERMINAL_BODY.scrollHeight;
  
    } else if (event.keyCode === KEYPRESS_UP) {
      // Implement 'command history cycling'; pressing 'UP' retrieves past commands
      if (TERMINAL_COMMAND_HISTORY.length >= 1) {
        var activeCommandLine = TERMINAL_BODY.lastElementChild;
        if (TERMINAL_COMMAND_HISTORY_POSITION == NO_COMMAND_HISTORY_CYCLED) {
          TERMINAL_COMMAND_HISTORY_POSITION = TERMINAL_COMMAND_HISTORY.length - 1;
        } else if (TERMINAL_COMMAND_HISTORY_POSITION == -1) {
          // We have exhausted our pool of historical commands, do nothing
          return;
        }
        activeCommandLine.getElementsByClassName('terminal-command')[0].value = TERMINAL_COMMAND_HISTORY[TERMINAL_COMMAND_HISTORY_POSITION];
        TERMINAL_COMMAND_HISTORY_POSITION--;
        resizeInput.call(TERMINAL_INPUT);
      }
    }
  }

  /*
   * Records the current command and prepare the terminal for the next command
   * 1. Create a new terminal line object with values based on the command entered
   * 2. Drop it into place in the 'shell' on the penultimate line
   * 3. Clean up the active command line so the user can type a new command
   */
  function recordCommand() {
    // Grab the final line of the terminal; containing the active command and store the command text
    var activeCommandLine = TERMINAL_BODY.lastElementChild;
    var commandText = activeCommandLine.getElementsByClassName('terminal-command')[0].value;
    var promptText = activeCommandLine.getElementsByClassName('terminal-prompt')[0].innerText;

    // Create the line to be returned with appropriate values
    var newLine = document.querySelector('#terminal-command-template').cloneNode(true);
    with (newLine) {
      getElementsByClassName('terminal-command')[0].innerText = commandText;
      getElementsByClassName('terminal-prompt')[0].innerText = promptText;
      id = '';
      className = 'terminal-line';
      removeAttribute('style');
    }

    TERMINAL_COMMAND_HISTORY.push(commandText);

    // Insert it into the DOM
    TERMINAL_BODY.insertBefore(newLine,activeCommandLine);
  }

  // Prints files to terminal output
  function printFiles(files) {
    var activeCommandLine = TERMINAL_BODY.lastElementChild;

    // Create the line to be returned from the template
    var newLine = document.querySelector('#terminal-output-template').cloneNode(true);
    with (newLine) {
      id = '';
      className = 'terminal-line';
      removeAttribute('style');
    }

    // Populate the new line with the file output
    var filesHtmlOutput = [];
    for (const rawFsObject in files) {
      // Check if the raw object is an object or a string to check if it is a file or directory
      var fsObject = new TerminalFsObject(rawFsObject, files[rawFsObject], files[rawFsObject] instanceof Object);
      filesHtmlOutput.push(fsObject.renderToHtml());
    }

    for (const fileOutput in filesHtmlOutput) {
      newLine.appendChild(filesHtmlOutput[fileOutput]);
    }

    // Finally, add the new line to the DOM
    TERMINAL_BODY.insertBefore(newLine,activeCommandLine);

  }

  function printText(text) {
    var activeCommandLine = TERMINAL_BODY.lastElementChild;

    // Create the line to be returned from the template
    var newLine = document.querySelector('#terminal-output-template').cloneNode(true);

    with (newLine) {
      getElementsByClassName('terminal-output')[0].innerText = text;
      id = '';
      className = 'terminal-line';
      removeAttribute('style');
    }

    // Insert it
    TERMINAL_BODY.insertBefore(newLine,activeCommandLine);
  }

  function getTerminalPath() {
    return `guest@danielbergamin.net:${TERMINAL_ACTIVE_DIR.join('/')} $`;
  }

  function getPathFromString(path) {
    if (path == '/') {
      return ['~'];
    }
    return path.split('/');
  }

  // Check if a path exists
  function isValidFilePath(path) {
    var splitPath = getPathFromString(path)
    var i = 0;
    var seekDir = TERMINAL_FILESYSTEM;
    while (i < splitPath.length && seekDir != undefined) {
      seekDir = seekDir[splitPath[i]];
      i = i + 1;
    }
    
    return (seekDir != undefined)
  }

  /*
   * Command implementations
   * Parameters:
   *   args: The raw string that follows the space after the command invocation
   *         e.g. the command "print hello 123" would pass "hello 123" in as args.
   */

  function commandChangeDir(args) {
    if (args.split(' ').length != 1 || args === NO_ARGS) {
      printText('Usage: cd [DIRECTORY_PATH]');
    } else {
      if (isValidFilePath(args)) {
        TERMINAL_ACTIVE_DIR = getPathFromString(args);
      } else {
        printText(`cd: directory ${args} not found`)
      }
    }
  }

  function commandClearScreen(args) {
    console.log("clear the screen");
  }

  function commandHelp(args) {
    var output = "This isn't a great way to navigate the site, but it was fun to make. Supported commands:\n";
    for (command in TERMINAL_COMMANDS) {
      output = output + `${TERMINAL_COMMANDS[command].name}: ${TERMINAL_COMMANDS[command].helptext}\n`;
    }
    printText(output);
  }

  function commandListDir(args) {
    var i = 0;
    var seekDir = TERMINAL_FILESYSTEM;
    while (i < TERMINAL_ACTIVE_DIR.length) {
      seekDir = seekDir[TERMINAL_ACTIVE_DIR[i]];
      i = i + 1;
    }

    printFiles(seekDir);
  }

  // Display an error if the command is not found.
  function commandNotFound(args) {
    alert("command " + args + " not found. Use `help` for more info.");
  }


  function commandPrint(args) {
    printText(args);
  }

  // Generic error behaviour
  function leaveMeAlone() {
    alert("Please don't try to break my fragile imitation of a shell, no bug bounties to be found here.");
  }

</script>